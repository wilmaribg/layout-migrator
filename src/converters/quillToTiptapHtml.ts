/**
 * Quill to TipTap HTML Converter
 *
 * Transforms HTML generated by Quill editor into HTML compatible with TipTap.
 * Processes each opening HTML tag as a unit to safely manipulate class/style
 * attributes without breaking tag structure.
 *
 * Transformations:
 * 1. ql-align-X class → text-align: X inline style
 * 2. ql-font-X class  → font-family: X inline style (resolved via fontMap)
 * 3. Strip pr-wildcard class and contenteditable attrs
 * 4. Normalize font names (remove __user__timestamp suffixes)
 */

import { resolveFontFamily } from './cssParser.js';

/**
 * Convert Quill HTML to TipTap-compatible HTML.
 *
 * Strategy: match every opening tag, parse its class and style attributes,
 * convert Quill-specific classes to inline styles, and reconstruct the tag.
 *
 * @param html The Quill HTML to convert
 * @param fontMap Optional map of original font names → new fontCodes (from font sync)
 */
export function quillToTiptapHtml(html: string, fontMap?: Record<string, string>): string {
  if (!html) return '';

  // Match every opening (or self-closing) HTML tag
  let result = html.replace(
    /<(\w+)(\s[^>]*)?\/?>/g,
    (fullMatch, tagName: string, attrsRaw: string | undefined) => {
      if (!attrsRaw) return fullMatch; // no attributes → nothing to transform

      const isSelfClosing = fullMatch.endsWith('/>');

      // ── Parse existing attributes ──
      let classes = extractAttr(attrsRaw, 'class') ?? '';
      let style = extractAttr(attrsRaw, 'style') ?? '';

      // Collect all other attributes (everything except class, style, contenteditable)
      const otherAttrs = attrsRaw
        .replace(/\s*class="[^"]*"/g, '')
        .replace(/\s*style="[^"]*"/g, '')
        .replace(/\s*contenteditable="[^"]*"/g, '')
        .trim();

      // ── Convert ql-align-* → text-align ──
      const alignMatch = classes.match(/\bql-align-(justify|center|right|left)\b/);
      if (alignMatch) {
        style = mergeStyles(style, `text-align: ${alignMatch[1]}`);
      }

      // ── Convert ql-font-* → font-family (resolved via fontMap) ──
      const fontMatch = classes.match(/\bql-font-(\S+)/);
      if (fontMatch) {
        style = mergeStyles(style, `font-family: ${resolveFontFamily(fontMatch[1], fontMap)}`);
      }

      // ── Clean up classes: remove ql-*, pr-wildcard ──
      classes = classes
        .replace(/\bql-align-\w+\b/g, '')
        .replace(/\bql-font-\S+/g, '')
        .replace(/\bpr-wildcard\b/g, '')
        .replace(/\s+/g, ' ')
        .trim();

      // ── Reconstruct the tag with clean attributes ──
      let newAttrs = '';
      if (otherAttrs) newAttrs += ' ' + otherAttrs;
      if (classes) newAttrs += ` class="${classes}"`;
      if (style) newAttrs += ` style="${style}"`;

      return `<${tagName}${newAttrs}${isSelfClosing ? ' /' : ''}>`;
    }
  );

  // Final cleanup: empty class attributes
  result = result.replace(/\s*class=""/g, '');
  result = result.replace(/\s*class="\s*"/g, '');

  return result;
}

/**
 * Extract the value of a named attribute from an attribute string.
 */
function extractAttr(attrs: string, name: string): string | null {
  const re = new RegExp(`\\s*${name}="([^"]*)"`);
  const m = attrs.match(re);
  return m ? m[1] : null;
}

/**
 * Merge two style strings, deduplicating properties.
 */
function mergeStyles(existing: string, newStyle: string): string {
  if (!existing) return newStyle;
  if (!newStyle) return existing;

  const styles = new Map<string, string>();

  // Parse existing
  for (const decl of existing.split(';')) {
    const [prop, ...vals] = decl.split(':');
    if (prop?.trim() && vals.length) {
      styles.set(prop.trim(), vals.join(':').trim());
    }
  }

  // Parse new (overrides existing)
  for (const decl of newStyle.split(';')) {
    const [prop, ...vals] = decl.split(':');
    if (prop?.trim() && vals.length) {
      styles.set(prop.trim(), vals.join(':').trim());
    }
  }

  return Array.from(styles.entries())
    .map(([prop, val]) => `${prop}: ${val}`)
    .join('; ');
}
